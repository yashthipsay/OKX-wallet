"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validSignedTransaction = exports.getSignHash = exports.getSignedTransaction = exports.getMPCSignedMessage = exports.getMPCTransaction = exports.verifyMessage = exports.signMPCMessage = exports.signMessage = exports.signTransaction = exports.validAddress = exports.getNewAddress = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const sdk_1 = require("./sdk");
const message_1 = require("./message");
const eth_sig_util_1 = require("./sdk/eth-sig-util");
const eth_sig_util_2 = require("eth-sig-util");
function getNewAddress(privateKeyHex) {
    const privateKey = crypto_lib_1.base.fromHex(privateKeyHex);
    const publicKey = (0, sdk_1.privateToPublic)(privateKey);
    const address = (0, sdk_1.publicToAddress)(publicKey);
    return {
        address: crypto_lib_1.base.toHex(address, true),
        publicKey: crypto_lib_1.base.toHex(publicKey, true)
    };
}
exports.getNewAddress = getNewAddress;
function validAddress(address) {
    let checksumAddress = '';
    const isValid = (0, sdk_1.isValidAddress)(address);
    checksumAddress = (0, sdk_1.toChecksumAddress)(address);
    return {
        isValid: isValid,
        address: checksumAddress
    };
}
exports.validAddress = validAddress;
function signTransaction(privateKeyHex, txData) {
    const tx = sdk_1.TransactionFactory.fromTxData(txData);
    if (!privateKeyHex) {
        return {
            raw: crypto_lib_1.base.toHex(Buffer.from(JSON.stringify(txData))),
            hash: crypto_lib_1.base.toHex(tx.getMessageToSign(true)),
            serializeRaw: crypto_lib_1.base.toHex(tx.serialize()),
        };
    }
    const privateKey = crypto_lib_1.base.fromHex(privateKeyHex);
    const signedTx = tx.sign(privateKey);
    return crypto_lib_1.base.toHex(signedTx.serialize(), true);
}
exports.signTransaction = signTransaction;
function signMessage(messageType, message, privateKey) {
    if (!privateKey) {
        return signMPCMessage(messageType, message);
    }
    if (messageType == message_1.MessageTypes.TYPE_DATA_V1) {
        return (0, eth_sig_util_2.signTypedMessage)(privateKey, { data: JSON.parse(message) }, "V1");
    }
    else if (messageType == message_1.MessageTypes.TYPE_DATA_V3) {
        return (0, eth_sig_util_2.signTypedMessage)(privateKey, { data: JSON.parse(message) }, "V3");
    }
    else if (messageType == message_1.MessageTypes.TYPE_DATA_V4) {
        return (0, eth_sig_util_2.signTypedMessage)(privateKey, { data: JSON.parse(message) }, "V4");
    }
    const msgHash = (0, message_1.hashMessage)(messageType, message);
    const { v, r, s } = (0, sdk_1.ecdsaSign)(crypto_lib_1.base.fromHex(msgHash), privateKey);
    return (0, sdk_1.makeSignature)(v, r, s);
}
exports.signMessage = signMessage;
function signMPCMessage(messageType, message) {
    if (messageType == message_1.MessageTypes.TYPE_DATA_V1) {
        return (0, eth_sig_util_2.typedSignatureHash)(JSON.parse(message));
    }
    else if (messageType == message_1.MessageTypes.TYPE_DATA_V3) {
        return crypto_lib_1.base.toHex(eth_sig_util_2.TypedDataUtils.sign(JSON.parse(message), false));
    }
    else if (messageType == message_1.MessageTypes.TYPE_DATA_V4) {
        return crypto_lib_1.base.toHex(eth_sig_util_2.TypedDataUtils.sign(JSON.parse(message)));
    }
    return (0, message_1.hashMessage)(messageType, message);
}
exports.signMPCMessage = signMPCMessage;
function verifyMessage(messageType, message, signature) {
    const msgHash = (0, message_1.hashMessage)(messageType, message);
    const [r, s, v] = [
        signature.slice(0, 32),
        signature.slice(32, 64),
        signature[64],
    ];
    return (0, sdk_1.recoverFromSignature)(crypto_lib_1.base.fromHex(msgHash), v, r, s);
}
exports.verifyMessage = verifyMessage;
function getMPCTransaction(raw, sig, publicKey) {
    let tx = sdk_1.TransactionFactory.fromTxData(JSON.parse(crypto_lib_1.base.fromHex(raw).toString()));
    const msgHash = tx.getMessageToSign(true);
    const signature = crypto_lib_1.base.fromHex(sig);
    const r = signature.slice(0, 32);
    const s = signature.slice(32, 64);
    const v = crypto_lib_1.signUtil.secp256k1.getV(msgHash, crypto_lib_1.base.toHex(r), crypto_lib_1.base.toHex(s), crypto_lib_1.base.fromHex(publicKey));
    tx = tx.processSignature(v + 27, r, s);
    return crypto_lib_1.base.toHex(tx.serialize(), true);
}
exports.getMPCTransaction = getMPCTransaction;
function getMPCSignedMessage(hash, sig, publicKey) {
    const signature = crypto_lib_1.base.fromHex(sig);
    const r = signature.slice(0, 32);
    const s = signature.slice(32, 64);
    const v = crypto_lib_1.signUtil.secp256k1.getV(crypto_lib_1.base.fromHex(hash), crypto_lib_1.base.toHex(r), crypto_lib_1.base.toHex(s), crypto_lib_1.base.fromHex(publicKey)) + 27;
    return (0, sdk_1.makeSignature)(v, r, s);
}
exports.getMPCSignedMessage = getMPCSignedMessage;
function getSignedTransaction(raw, r, s, v) {
    let tx = sdk_1.TransactionFactory.fromSerializedData(crypto_lib_1.base.fromHex(raw));
    tx = tx.processSignatureWithRawV(parseInt(v, 16), crypto_lib_1.base.fromHex(r), crypto_lib_1.base.fromHex(s));
    return crypto_lib_1.base.toHex(tx.serialize(), true);
}
exports.getSignedTransaction = getSignedTransaction;
function getSignHash(raw) {
    let tx = sdk_1.TransactionFactory.fromSerializedData(crypto_lib_1.base.fromHex(raw));
    return crypto_lib_1.base.toHex(tx.getMessageToSign(true));
}
exports.getSignHash = getSignHash;
function validSignedTransaction(tx, chainId, publicKey) {
    const signedTx = sdk_1.TransactionFactory.fromSerializedData(crypto_lib_1.base.fromHex(tx), chainId);
    const msgHash = signedTx.getMessageToSign(true);
    const rStr = (0, eth_sig_util_1.padWithZeroes)(crypto_lib_1.base.toHex(signedTx.r.toArrayLike(Buffer)), 64);
    const sStr = (0, eth_sig_util_1.padWithZeroes)(crypto_lib_1.base.toHex(signedTx.s.toArrayLike(Buffer)), 64);
    const rs = crypto_lib_1.base.fromHex(rStr.concat(sStr));
    if (publicKey && !crypto_lib_1.signUtil.secp256k1.verifyWithNoRecovery(msgHash, rs, crypto_lib_1.base.fromHex(publicKey))) {
        return new Error("signature error");
    }
    return signedTx;
}
exports.validSignedTransaction = validSignedTransaction;
//# sourceMappingURL=api.js.map