"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_util_1 = require("../ethereumjs-util");
const baseTransaction_1 = require("./baseTransaction");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const TRANSACTION_TYPE = 0;
class Transaction extends baseTransaction_1.BaseTransaction {
    static fromTxData(txData) {
        return new Transaction(txData);
    }
    static fromSerializedTx(serialized, chainId) {
        const values = ethereumjs_util_1.rlp.decode(serialized);
        if (!Array.isArray(values)) {
            throw new Error('Invalid serialized tx input. Must be array');
        }
        return this.fromValuesArray(values, chainId);
    }
    static fromValuesArray(values, chainId) {
        if (values.length !== 6 && values.length !== 9) {
            throw new Error('Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).');
        }
        const [nonce, gasPrice, gasLimit, to, value, data, v, r, s] = values;
        (0, ethereumjs_util_1.validateNoLeadingZeroes)({ nonce, gasPrice, gasLimit, value, v, r, s });
        return new Transaction({
            nonce,
            gasPrice,
            gasLimit,
            to,
            value,
            data,
            v,
            r,
            s,
            chainId
        });
    }
    constructor(txData) {
        super({ ...txData, type: TRANSACTION_TYPE });
        this.gasPrice = new crypto_lib_1.BN((0, ethereumjs_util_1.toBuffer)(txData.gasPrice === '' ? '0x' : txData.gasPrice));
        this.chainId = new crypto_lib_1.BN((0, ethereumjs_util_1.toBuffer)(txData.chainId === '' ? '0x' : txData.chainId));
        if (this.gasPrice.mul(this.gasLimit).gt(ethereumjs_util_1.MAX_INTEGER)) {
            const msg = this._errorMsg('gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)');
            throw new Error(msg);
        }
        this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice });
    }
    raw() {
        return [
            (0, ethereumjs_util_1.bnToUnpaddedBuffer)(this.nonce),
            (0, ethereumjs_util_1.bnToUnpaddedBuffer)(this.gasPrice),
            (0, ethereumjs_util_1.bnToUnpaddedBuffer)(this.gasLimit),
            this.to !== undefined ? this.to.buf : Buffer.from([]),
            (0, ethereumjs_util_1.bnToUnpaddedBuffer)(this.value),
            this.data,
            this.v !== undefined ? (0, ethereumjs_util_1.bnToUnpaddedBuffer)(this.v) : Buffer.from([]),
            this.r !== undefined ? (0, ethereumjs_util_1.bnToUnpaddedBuffer)(this.r) : Buffer.from([]),
            this.s !== undefined ? (0, ethereumjs_util_1.bnToUnpaddedBuffer)(this.s) : Buffer.from([]),
        ];
    }
    serialize() {
        return ethereumjs_util_1.rlp.encode(this.raw());
    }
    _getMessageToSign() {
        const values = [
            (0, ethereumjs_util_1.bnToUnpaddedBuffer)(this.nonce),
            (0, ethereumjs_util_1.bnToUnpaddedBuffer)(this.gasPrice),
            (0, ethereumjs_util_1.bnToUnpaddedBuffer)(this.gasLimit),
            this.to !== undefined ? this.to.buf : Buffer.from([]),
            (0, ethereumjs_util_1.bnToUnpaddedBuffer)(this.value),
            this.data,
            (0, ethereumjs_util_1.toBuffer)(this.chainId),
            (0, ethereumjs_util_1.unpadBuffer)((0, ethereumjs_util_1.toBuffer)(0)),
            (0, ethereumjs_util_1.unpadBuffer)((0, ethereumjs_util_1.toBuffer)(0)),
        ];
        return values;
    }
    getMessageToSign(hashMessage = true) {
        const message = this._getMessageToSign();
        if (hashMessage) {
            return (0, ethereumjs_util_1.rlphash)(message);
        }
        else {
            return message;
        }
    }
    hash() {
        return (0, ethereumjs_util_1.rlphash)(this.raw());
    }
    _processSignature(v, r, s) {
        const vBN = new crypto_lib_1.BN(2 * this.chainId.toNumber() + v + 8);
        return Transaction.fromTxData({
            nonce: this.nonce,
            gasPrice: this.gasPrice,
            gasLimit: this.gasLimit,
            to: this.to,
            value: this.value,
            data: this.data,
            chainId: this.chainId,
            v: vBN,
            r: new crypto_lib_1.BN(r),
            s: new crypto_lib_1.BN(s),
        });
    }
    _processSignatureWithRawV(v, r, s) {
        return Transaction.fromTxData({
            nonce: this.nonce,
            gasPrice: this.gasPrice,
            gasLimit: this.gasLimit,
            to: this.to,
            value: this.value,
            data: this.data,
            chainId: this.chainId,
            v: new crypto_lib_1.BN(v),
            r: new crypto_lib_1.BN(r),
            s: new crypto_lib_1.BN(s),
        });
    }
    toJSON() {
        return {
            nonce: (0, ethereumjs_util_1.bnToHex)(this.nonce),
            gasPrice: (0, ethereumjs_util_1.bnToHex)(this.gasPrice),
            gasLimit: (0, ethereumjs_util_1.bnToHex)(this.gasLimit),
            to: this.to !== undefined ? this.to.toString() : undefined,
            value: (0, ethereumjs_util_1.bnToHex)(this.value),
            data: '0x' + this.data.toString('hex'),
            v: this.v !== undefined ? (0, ethereumjs_util_1.bnToHex)(this.v) : undefined,
            r: this.r !== undefined ? (0, ethereumjs_util_1.bnToHex)(this.r) : undefined,
            s: this.s !== undefined ? (0, ethereumjs_util_1.bnToHex)(this.s) : undefined,
        };
    }
    errorStr() {
        let errorStr = this._getSharedErrorPostfix();
        errorStr += ` gasPrice=${this.gasPrice}`;
        return errorStr;
    }
    _errorMsg(msg) {
        return `${msg} (${this.errorStr()})`;
    }
}
exports.default = Transaction;
//# sourceMappingURL=legacyTransaction.js.map