"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_util_1 = require("../ethereumjs-util");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const _1 = require(".");
class TransactionFactory {
    static fromTxData(txData) {
        if (!('type' in txData) || txData.type === undefined) {
            return _1.Transaction.fromTxData(txData);
        }
        else {
            const txType = new crypto_lib_1.BN((0, ethereumjs_util_1.toBuffer)(txData.type)).toNumber();
            if (txType === 0) {
                return _1.Transaction.fromTxData(txData);
            }
            else if (txType === 1) {
                return _1.AccessListEIP2930Transaction.fromTxData(txData);
            }
            else if (txType === 2) {
                return _1.FeeMarketEIP1559Transaction.fromTxData(txData);
            }
            else {
                throw new Error(`Tx instantiation with type ${txType} not supported`);
            }
        }
    }
    static fromSerializedData(data, chainId) {
        if (data[0] <= 0x7f) {
            let EIP;
            switch (data[0]) {
                case 1:
                    EIP = 2930;
                    break;
                case 2:
                    EIP = 1559;
                    break;
                default:
                    throw new Error(`TypedTransaction with ID ${data[0]} unknown`);
            }
            if (EIP === 1559) {
                return _1.FeeMarketEIP1559Transaction.fromSerializedTx(data);
            }
            else {
                return _1.AccessListEIP2930Transaction.fromSerializedTx(data);
            }
        }
        else {
            return _1.Transaction.fromSerializedTx(data, chainId);
        }
    }
}
exports.default = TransactionFactory;
//# sourceMappingURL=transactionFactory.js.map