"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseTransaction = exports.Chain = void 0;
const ethereumjs_util_1 = require("../ethereumjs-util");
const crypto_lib_1 = require("@okxweb3/crypto-lib");
var Chain;
(function (Chain) {
    Chain[Chain["Mainnet"] = 1] = "Mainnet";
    Chain[Chain["Ropsten"] = 3] = "Ropsten";
    Chain[Chain["Rinkeby"] = 4] = "Rinkeby";
    Chain[Chain["Kovan"] = 42] = "Kovan";
    Chain[Chain["Goerli"] = 5] = "Goerli";
    Chain[Chain["Sepolia"] = 11155111] = "Sepolia";
})(Chain = exports.Chain || (exports.Chain = {}));
class BaseTransaction {
    constructor(txData) {
        this.activeCapabilities = [];
        this.DEFAULT_CHAIN = Chain.Mainnet;
        const { nonce, gasLimit, to, value, data, v, r, s, type } = txData;
        this._type = new crypto_lib_1.BN((0, ethereumjs_util_1.toBuffer)(type)).toNumber();
        const toB = (0, ethereumjs_util_1.toBuffer)(to === '' ? '0x' : to);
        const vB = (0, ethereumjs_util_1.toBuffer)(v === '' ? '0x' : v);
        const rB = (0, ethereumjs_util_1.toBuffer)(r === '' ? '0x' : r);
        const sB = (0, ethereumjs_util_1.toBuffer)(s === '' ? '0x' : s);
        this.nonce = new crypto_lib_1.BN((0, ethereumjs_util_1.toBuffer)(nonce === '' ? '0x' : nonce));
        this.gasLimit = new crypto_lib_1.BN((0, ethereumjs_util_1.toBuffer)(gasLimit === '' ? '0x' : gasLimit));
        this.to = toB.length > 0 ? new ethereumjs_util_1.Address(toB) : undefined;
        this.value = new crypto_lib_1.BN((0, ethereumjs_util_1.toBuffer)(value === '' ? '0x' : value));
        this.data = (0, ethereumjs_util_1.toBuffer)(data === '' ? '0x' : data);
        this.v = vB.length > 0 ? new crypto_lib_1.BN(vB) : undefined;
        this.r = rB.length > 0 ? new crypto_lib_1.BN(rB) : undefined;
        this.s = sB.length > 0 ? new crypto_lib_1.BN(sB) : undefined;
        this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s });
        this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64);
        this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true);
    }
    get transactionType() {
        return this.type;
    }
    get type() {
        return this._type;
    }
    isSigned() {
        const { v, r, s } = this;
        if (this.type === 0) {
            if (!v || !r || !s) {
                return false;
            }
            else {
                return true;
            }
        }
        else {
            if (v === undefined || !r || !s) {
                return false;
            }
            else {
                return true;
            }
        }
    }
    sign(privateKey) {
        if (privateKey.length !== 32) {
            const msg = this._errorMsg('Private key must be 32 bytes in length.');
            throw new Error(msg);
        }
        const msgHash = this.getMessageToSign(true);
        const { v, r, s } = (0, ethereumjs_util_1.ecdsaSign)(msgHash, privateKey);
        return this._processSignature(v, r, s);
    }
    _validateCannotExceedMaxInteger(values, bits = 256, cannotEqual = false) {
        for (const [key, value] of Object.entries(values)) {
            switch (bits) {
                case 64:
                    if (cannotEqual) {
                        if (value?.gte(ethereumjs_util_1.MAX_UINT64)) {
                            const msg = this._errorMsg(`${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`);
                            throw new Error(msg);
                        }
                    }
                    else {
                        if (value?.gt(ethereumjs_util_1.MAX_UINT64)) {
                            const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`);
                            throw new Error(msg);
                        }
                    }
                    break;
                case 256:
                    if (cannotEqual) {
                        if (value?.gte(ethereumjs_util_1.MAX_INTEGER)) {
                            const msg = this._errorMsg(`${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`);
                            throw new Error(msg);
                        }
                    }
                    else {
                        if (value?.gt(ethereumjs_util_1.MAX_INTEGER)) {
                            const msg = this._errorMsg(`${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`);
                            throw new Error(msg);
                        }
                    }
                    break;
                default: {
                    const msg = this._errorMsg('unimplemented bits value');
                    throw new Error(msg);
                }
            }
        }
    }
    _getSharedErrorPostfix() {
        let hash = '';
        try {
            hash = this.isSigned() ? (0, ethereumjs_util_1.bufferToHex)(this.hash()) : 'not available (unsigned)';
        }
        catch (e) {
            hash = 'error';
        }
        let isSigned = '';
        try {
            isSigned = this.isSigned().toString();
        }
        catch (e) {
            hash = 'error';
        }
        let postfix = `tx type=${this.type} hash=${hash} nonce=${this.nonce} value=${this.value} `;
        postfix += `signed=${isSigned}`;
        return postfix;
    }
    processSignature(v, r, s) {
        return this._processSignature(v, r, s);
    }
    processSignatureWithRawV(v, r, s) {
        return this._processSignatureWithRawV(v, r, s);
    }
}
exports.BaseTransaction = BaseTransaction;
//# sourceMappingURL=baseTransaction.js.map