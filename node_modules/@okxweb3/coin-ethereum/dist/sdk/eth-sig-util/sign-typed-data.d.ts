/// <reference types="node" />
import { Struct } from "superstruct";
export type TypedDataV1 = TypedDataV1Field[];
export type Hex = `0x${string}`;
export declare const StrictHexStruct: Struct<`0x${string}`, null>;
export interface TypedDataV1Field {
    name: string;
    type: string;
    value: any;
}
export declare enum SignTypedDataVersion {
    V1 = "V1",
    V3 = "V3",
    V4 = "V4"
}
export interface MessageTypeProperty {
    name: string;
    type: string;
}
export interface MessageTypes {
    EIP712Domain: MessageTypeProperty[];
    [additionalProperties: string]: MessageTypeProperty[];
}
export type Bytes = bigint | number | string | Uint8Array;
export declare function assert(condition: any, errorMsg: string): void;
export declare function numberToBytes(value: number): Uint8Array;
export declare function stringToBytes(value: string): Uint8Array;
export declare function isBytes(value: unknown): value is Uint8Array;
export declare function valueToBytes(value: Bytes): Uint8Array;
export declare function concatBytes(values: Bytes[]): Uint8Array;
export declare function assertIsHexString(value: unknown): asserts value is string;
export declare function isStrictHexString(value: unknown): value is Hex;
export declare function hexToBytes(value: string): Uint8Array;
export declare function add0x(hexadecimal: string): Hex;
export declare function remove0x(hexadecimal: string): string;
export declare function bigIntToBytes(value: bigint): Uint8Array;
export declare function padStart(buffer: Uint8Array, length?: number): Uint8Array;
export declare const getErrorStack: (error?: unknown) => string | undefined;
export declare const getLength: (type: string) => number;
export interface TypedMessage<T extends MessageTypes> {
    types: T;
    primaryType: keyof T;
    domain: {
        name?: string;
        version?: string;
        chainId?: number;
        verifyingContract?: string;
        salt?: ArrayBuffer;
    };
    message: Record<string, unknown>;
}
export declare const TYPED_MESSAGE_SCHEMA: {
    type: string;
    properties: {
        types: {
            type: string;
            additionalProperties: {
                type: string;
                items: {
                    type: string;
                    properties: {
                        name: {
                            type: string;
                        };
                        type: {
                            type: string;
                            enum: string[];
                        };
                    };
                    required: string[];
                };
            };
        };
        primaryType: {
            type: string;
        };
        domain: {
            type: string;
        };
        message: {
            type: string;
        };
    };
    required: string[];
};
declare function encodeData(primaryType: string, data: Record<string, unknown>, types: Record<string, MessageTypeProperty[]>, version: SignTypedDataVersion.V3 | SignTypedDataVersion.V4): Buffer;
declare function encodeType(primaryType: string, types: Record<string, MessageTypeProperty[]>): string;
declare function hashType(primaryType: string, types: Record<string, MessageTypeProperty[]>): Buffer;
declare function eip712Hash<T extends MessageTypes>(typedData: TypedMessage<T>, version: SignTypedDataVersion.V3 | SignTypedDataVersion.V4): Buffer;
export declare const TypedDataUtils: {
    encodeData: typeof encodeData;
    encodeType: typeof encodeType;
    hashType: typeof hashType;
    eip712Hash: typeof eip712Hash;
};
export declare function typedSignatureHash(typedData: TypedDataV1Field[]): string;
export {};
