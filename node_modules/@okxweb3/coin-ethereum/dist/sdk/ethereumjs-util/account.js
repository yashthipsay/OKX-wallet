"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.toChecksumAddress = exports.isValidAddress = void 0;
const assert_1 = __importDefault(require("assert"));
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const hash_1 = require("./hash");
const helpers_1 = require("./helpers");
const types_1 = require("./types");
const isValidAddress = function (hexAddress) {
    (0, helpers_1.assertIsHexString)(hexAddress);
    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);
};
exports.isValidAddress = isValidAddress;
const toChecksumAddress = function (hexAddress, eip1191ChainId) {
    (0, helpers_1.assertIsHexString)(hexAddress);
    const address = crypto_lib_1.base.stripHexPrefix(hexAddress).toLowerCase();
    let prefix = '';
    if (eip1191ChainId) {
        const chainId = (0, types_1.toType)(eip1191ChainId, types_1.TypeOutput.BN);
        prefix = chainId.toString() + '0x';
    }
    const hash = (0, hash_1.keccakFromString)(prefix + address).toString('hex');
    let ret = '0x';
    for (let i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
            ret += address[i].toUpperCase();
        }
        else {
            ret += address[i];
        }
    }
    return ret;
};
exports.toChecksumAddress = toChecksumAddress;
const pubToAddress = function (pubKey, sanitize = false) {
    (0, helpers_1.assertIsBuffer)(pubKey);
    if (sanitize && pubKey.length !== 64) {
        const up = crypto_lib_1.signUtil.secp256k1.publicKeyConvert(pubKey, false);
        pubKey = Buffer.from(up.slice(1));
    }
    (0, assert_1.default)(pubKey.length === 64);
    return (0, hash_1.keccak)(pubKey).slice(-20);
};
exports.pubToAddress = pubToAddress;
exports.publicToAddress = exports.pubToAddress;
const privateToPublic = function (privateKey) {
    (0, helpers_1.assertIsBuffer)(privateKey);
    return crypto_lib_1.signUtil.secp256k1.publicKeyCreate(privateKey, false).slice(1);
};
exports.privateToPublic = privateToPublic;
const privateToAddress = function (privateKey) {
    return (0, exports.publicToAddress)((0, exports.privateToPublic)(privateKey));
};
exports.privateToAddress = privateToAddress;
//# sourceMappingURL=account.js.map