"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addHexPrefix = exports.toUnsigned = exports.fromSigned = exports.bufferToHex = exports.toBuffer = exports.unpadArray = exports.unpadBuffer = exports.stripZeros = exports.setLengthLeft = exports.zeros = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const crypto_lib_2 = require("@okxweb3/crypto-lib");
const util_1 = require("./util");
const helpers_1 = require("./helpers");
const zeros = function (bytes) {
    return Buffer.allocUnsafe(bytes).fill(0);
};
exports.zeros = zeros;
const setLength = function (msg, length, right) {
    const buf = (0, exports.zeros)(length);
    if (right) {
        if (msg.length < length) {
            msg.copy(buf);
            return buf;
        }
        return msg.slice(0, length);
    }
    else {
        if (msg.length < length) {
            msg.copy(buf, length - msg.length);
            return buf;
        }
        return msg.slice(-length);
    }
};
const setLengthLeft = function (msg, length) {
    (0, helpers_1.assertIsBuffer)(msg);
    return setLength(msg, length, false);
};
exports.setLengthLeft = setLengthLeft;
const stripZeros = function (a) {
    let first = a[0];
    while (a.length > 0 && first.toString() === '0') {
        a = a.slice(1);
        first = a[0];
    }
    return a;
};
exports.stripZeros = stripZeros;
const unpadBuffer = function (a) {
    (0, helpers_1.assertIsBuffer)(a);
    return (0, exports.stripZeros)(a);
};
exports.unpadBuffer = unpadBuffer;
const unpadArray = function (a) {
    (0, helpers_1.assertIsArray)(a);
    return (0, exports.stripZeros)(a);
};
exports.unpadArray = unpadArray;
const toBuffer = function (v) {
    if (v === null || v === undefined) {
        return Buffer.allocUnsafe(0);
    }
    if (Buffer.isBuffer(v)) {
        return Buffer.from(v);
    }
    if (Array.isArray(v) || v instanceof Uint8Array) {
        return Buffer.from(v);
    }
    if (typeof v === 'string') {
        if (!(0, util_1.isHexString)(v)) {
            throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${v}`);
        }
        return Buffer.from((0, util_1.padToEven)(crypto_lib_2.base.stripHexPrefix(v)), 'hex');
    }
    if (typeof v === 'number') {
        return (0, util_1.intToBuffer)(v);
    }
    if (crypto_lib_1.BN.isBN(v)) {
        return v.toArrayLike(Buffer);
    }
    if (v.toArray) {
        return Buffer.from(v.toArray());
    }
    if (v.toBuffer) {
        return Buffer.from(v.toBuffer());
    }
    throw new Error('invalid type');
};
exports.toBuffer = toBuffer;
const bufferToHex = function (buf) {
    buf = (0, exports.toBuffer)(buf);
    return '0x' + buf.toString('hex');
};
exports.bufferToHex = bufferToHex;
const fromSigned = function (num) {
    return new crypto_lib_1.BN(num).fromTwos(256);
};
exports.fromSigned = fromSigned;
const toUnsigned = function (num) {
    return Buffer.from(num.toTwos(256).toArray());
};
exports.toUnsigned = toUnsigned;
const addHexPrefix = function (str) {
    if (typeof str !== 'string') {
        return str;
    }
    return crypto_lib_2.base.isHexPrefixed(str) ? str : '0x' + str;
};
exports.addHexPrefix = addHexPrefix;
//# sourceMappingURL=bytes.js.map