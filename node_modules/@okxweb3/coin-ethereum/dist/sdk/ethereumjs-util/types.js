"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toType = exports.TypeOutput = exports.bnToRlp = exports.bnToUnpaddedBuffer = exports.validateNoLeadingZeroes = exports.bnToHex = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
const util_1 = require("./util");
const bytes_1 = require("./bytes");
function bnToHex(value) {
    return `0x${value.toString(16)}`;
}
exports.bnToHex = bnToHex;
const validateNoLeadingZeroes = function (values) {
    for (const [k, v] of Object.entries(values)) {
        if (v !== undefined && v.length > 0 && v[0] === 0) {
            throw new Error(`${k} cannot have leading zeroes, received: ${v.toString('hex')}`);
        }
    }
};
exports.validateNoLeadingZeroes = validateNoLeadingZeroes;
function bnToUnpaddedBuffer(value) {
    return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));
}
exports.bnToUnpaddedBuffer = bnToUnpaddedBuffer;
function bnToRlp(value) {
    return (0, bytes_1.unpadBuffer)(value.toArrayLike(Buffer));
}
exports.bnToRlp = bnToRlp;
var TypeOutput;
(function (TypeOutput) {
    TypeOutput[TypeOutput["Number"] = 0] = "Number";
    TypeOutput[TypeOutput["BN"] = 1] = "BN";
    TypeOutput[TypeOutput["Buffer"] = 2] = "Buffer";
    TypeOutput[TypeOutput["PrefixedHexString"] = 3] = "PrefixedHexString";
})(TypeOutput = exports.TypeOutput || (exports.TypeOutput = {}));
function toType(input, outputType) {
    if (typeof input === 'string' && !(0, util_1.isHexString)(input)) {
        throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
    }
    else if (typeof input === 'number' && !Number.isSafeInteger(input)) {
        throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)');
    }
    input = (0, bytes_1.toBuffer)(input);
    if (outputType === TypeOutput.Buffer) {
        return input;
    }
    else if (outputType === TypeOutput.BN) {
        return new crypto_lib_1.BN(input);
    }
    else if (outputType === TypeOutput.Number) {
        const bn = new crypto_lib_1.BN(input);
        const max = new crypto_lib_1.BN(Number.MAX_SAFE_INTEGER.toString());
        if (bn.gt(max)) {
            throw new Error('The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)');
        }
        return bn.toNumber();
    }
    else {
        return `0x${input.toString('hex')}`;
    }
}
exports.toType = toType;
//# sourceMappingURL=types.js.map