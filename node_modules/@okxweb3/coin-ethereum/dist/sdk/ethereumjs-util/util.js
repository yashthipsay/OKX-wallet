"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.numberToBuffer = exports.isHexString = exports.getKeys = exports.fromAscii = exports.fromUtf8 = exports.toAscii = exports.toUtf8 = exports.getBinarySize = exports.intToBuffer = exports.intToHex = exports.padToEven = void 0;
const crypto_lib_1 = require("@okxweb3/crypto-lib");
function padToEven(value) {
    let a = value;
    if (typeof a !== 'string') {
        throw new Error(`[ethjs-util] while padding to even, value must be string, is currently ${typeof a}, while padToEven.`);
    }
    if (a.length % 2) {
        a = `0${a}`;
    }
    return a;
}
exports.padToEven = padToEven;
function intToHex(i) {
    const hex = i.toString(16);
    return `0x${hex}`;
}
exports.intToHex = intToHex;
function intToBuffer(i) {
    const hex = intToHex(i);
    return Buffer.from(padToEven(hex.slice(2)), 'hex');
}
exports.intToBuffer = intToBuffer;
function getBinarySize(str) {
    if (typeof str !== 'string') {
        throw new Error(`[ethjs-util] while getting binary size, method getBinarySize requires input 'str' to be type String, got '${typeof str}'.`);
    }
    return Buffer.byteLength(str, 'utf8');
}
exports.getBinarySize = getBinarySize;
function toUtf8(hex) {
    const bufferValue = new Buffer(padToEven(crypto_lib_1.base.stripHexPrefix(hex).replace(/^0+|0+$/g, '')), 'hex');
    return bufferValue.toString('utf8');
}
exports.toUtf8 = toUtf8;
function toAscii(hex) {
    var str = '';
    var i = 0, l = hex.length;
    if (hex.substring(0, 2) === '0x') {
        i = 2;
    }
    for (; i < l; i += 2) {
        const code = parseInt(hex.substr(i, 2), 16);
        str += String.fromCharCode(code);
    }
    return str;
}
exports.toAscii = toAscii;
function fromUtf8(stringValue) {
    const str = new Buffer(stringValue, 'utf8');
    return `0x${padToEven(str.toString('hex')).replace(/^0+|0+$/g, '')}`;
}
exports.fromUtf8 = fromUtf8;
function fromAscii(stringValue) {
    var hex = '';
    for (var i = 0; i < stringValue.length; i++) {
        const code = stringValue.charCodeAt(i);
        const n = code.toString(16);
        hex += n.length < 2 ? `0${n}` : n;
    }
    return `0x${hex}`;
}
exports.fromAscii = fromAscii;
function getKeys(params, key, allowEmpty) {
    if (!Array.isArray(params)) {
        throw new Error(`[ethjs-util] method getKeys expecting type Array as 'params' input, got '${typeof params}'`);
    }
    if (typeof key !== 'string') {
        throw new Error(`[ethjs-util] method getKeys expecting type String for input 'key' got '${typeof key}'.`);
    }
    var result = [];
    for (var i = 0; i < params.length; i++) {
        var value = params[i][key];
        if (allowEmpty && !value) {
            value = '';
        }
        else if (typeof (value) !== 'string') {
            throw new Error('invalid abi');
        }
        result.push(value);
    }
    return result;
}
exports.getKeys = getKeys;
function isHexString(value, length) {
    if (typeof (value) !== 'string' || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length && value.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}
exports.isHexString = isHexString;
function numberToBuffer(num) {
    const hexVal = num.toString(16);
    const prepend = hexVal.length % 2 ? '0' : '';
    return Buffer.from(prepend + hexVal, 'hex');
}
exports.numberToBuffer = numberToBuffer;
//# sourceMappingURL=util.js.map